"""
https://leetcode.com/problems/minimize-malware-spread-ii/?envType=study-plan&id=graph-ii

so same idea, union all connected nodes first

then for each initial-node, 
    if it is only one in inital and its group, then removing it won't affect other groups

    if its group set have more than on in the initial set
        I need to serve the connection?
        hmmm? how does it affect the result?

        because its connections to all other nodes are served
        it will definitely be dis-infected itself...

        however... 
not so obvious but I see a brute force way?
I remove every one.. and check how many infected nodes. 

the data scopt is not super big.. maybe I can give a shot
    
"""


from collections import defaultdict
from typing import List


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        roots = []

        def find(x):
            if roots[x] != x:
                roots[x] = find(roots[x])
            return roots[x]
        
        def union(x,y):
            roots[find(x)] = roots[find(y)]

        def infected(rmIdx):
            nonlocal roots
            roots = [i for i in range(n)]

            for i in range(n):
                if i == rmIdx:
                    continue
                for j in range(i+1, n):
                    if j == rmIdx:
                        continue
                    if graph[i][j]:
                        union(i,j)
            
            rootSet = defaultdict(set)
            for node in range(len(roots)):
                root = find(node)
                rootSet[root].add(node)

            infectedNodes = 0
            processed = set()
            initialSet = set(initial)
            for i in initial:
                if i==rmIdx or i in processed:
                    continue
                
                root = find(i)
                infectedNodes += len(rootSet[root])
                processed = processed.union(rootSet[root].intersection(initialSet))
            return infectedNodes
        
        infectedNodesMin = n+1
        res = -1
        for i in initial:
            infectedNodes = infected(i)
            if infectedNodes < infectedNodesMin:
                infectedNodesMin = infectedNodes
                res = i
            elif infectedNodes == infectedNodesMin:
                res = min(res, i)
        
        return res

"""
Runtime: 2057 ms, faster than 37.01% of Python3 online submissions for Minimize Malware Spread II.
Memory Usage: 16.6 MB, less than 72.08% of Python3 online submissions for Minimize Malware Spread II.

this solution is kind of like brute force..
I read and see there is this solution
    1. union find all the clean nodes
    2. stats about each union

    3. for each malware
        if it is directed connect to some union, then update that union's root infectConnectionCount 
        if it is not directed connected, 
            i.e. it could be not connected
                 or connected by another malware, then it can be mitigated by removing that directly connected 
                 a bit suspision here.. will this be right?
    4. then for each union,
        if direct connections are only one then removing that could provide a save
        bigger save wins
        equal save, lowest index wins..

this would be the general idea
let me see if I can code it out
"""


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        roots = [i for i in range(n)]
        def find(x):
            if roots[x] != x:
                roots[x] = find(roots[x])
            return roots[x]

        def union(x, y):
            roots[find(x)] = roots[find(y)]

        cleanNodes = set(range(n)).difference(set(initial))
        # connect clean nodes
        for i in cleanNodes:
            for j in cleanNodes:
                if graph[i][j]:
                    union(i,j)
            
        unionSize = defaultdict(int)
        for i in cleanNodes:
            unionSize[find(i)] += 1

        malwareToUnions = defaultdict(set) # map malware to direct connect groups 
        unionConnMalware =  defaultdict(int) # map each union (represented by root) to count of direct connected malware
        for i in initial:
            for j in cleanNodes:
                if graph[i][j]:
                    malwareToUnions[i].add(find(j))

            for u in malwareToUnions[i]:
                unionConnMalware[u] += 1

        # try removing each malware
        res = initial[0]        
        maxCnt = -1

        for malware, unions in malwareToUnions.items():
            count = 0
            for u in unions:
                if unionConnMalware[u] == 1:
                    count += unionSize[u]

            if count > maxCnt or (count==maxCnt and malware<res):
                maxCnt = count
                res = malware
        return res

"""
Runtime: 1001 ms, faster than 76.16% of Python3 online submissions for Minimize Malware Spread II.
Memory Usage: 16.6 MB, less than 68.87% of Python3 online submissions for Minimize Malware Spread II.

logic is not easy
the last part is to find the max clean nodes I can save by removing me.. 


"""

if __name__ == '__main__':
    s = Solution()
    print(s.minMalwareSpread(
        graph=[[1, 1, 0], [1, 1, 0], [0, 0, 1]], initial=[0, 1]))
    print(s.minMalwareSpread(
        graph=[[1, 1, 0], [1, 1, 1], [0, 1, 1]], initial=[0, 1]))


    print(s.minMalwareSpread(
        graph=[[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]], initial=[0, 1]))

    print(s.minMalwareSpread(
        graph=[[1, 1, 0, 0], [1, 1, 0, 1], [0, 0, 1, 0], [0, 1, 0, 1]], initial=[3,0]))
